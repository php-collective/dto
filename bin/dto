#!/usr/bin/env php
<?php

declare(strict_types=1);

/**
 * Standalone CLI for DTO generation.
 *
 * Usage:
 *   vendor/bin/dto generate [options]
 *   vendor/bin/dto typescript [options]
 *   vendor/bin/dto jsonschema [options]
 *
 * Commands:
 *   generate Generate PHP DTOs from configuration (default)
 *   typescript Generate TypeScript interfaces from configuration
 *   jsonschema Generate JSON Schema from configuration
 *
 * Options:
 *   --config-path=PATH Path to config directory (default: config/)
 *   --src-path=PATH Path to src directory (default: src/)
 *   --output=PATH Path for TypeScript/JSON Schema output (default: types/ or schemas/)
 *   --namespace=NS Namespace for generated DTOs (default: App)
 *   --format=FORMAT Config format: xml, yaml, neon (default: auto-detect)
 *   --dry-run Show what would be generated without writing files
 *   --force Regenerate all DTOs, ignoring existing
 *   --verbose, -v Verbose output
 *   --quiet, -q Quiet output
 *   --help, -h Show this help
 *
 * TypeScript Options:
 *   --single-file Generate all types in one file (default: true)
 *   --multi-file Generate each type in separate file
 *   --readonly Make all fields readonly
 *   --strict-nulls Use '| null' instead of '?'
 *   --file-case=CASE File naming: pascal, dashed, snake (default: pascal)
 *
 * JSON Schema Options:
 *   --single-file Generate all schemas in one file with $defs (default: true)
 *   --multi-file Generate each schema in separate file
 *   --no-refs Inline nested DTOs instead of using $ref
 *   --date-format=FORMAT Date format: date-time, date, string (default: date-time)
 */

// Find autoloader
$autoloaderPaths = [
    __DIR__ . '/../vendor/autoload.php', // Development
    __DIR__ . '/../../../autoload.php', // Installed as dependency
];

$autoloader = null;
foreach ($autoloaderPaths as $path) {
    if (file_exists($path)) {
        $autoloader = require $path;

        break;
    }
}

if ($autoloader === null) {
    fwrite(STDERR, "Could not find autoloader. Run 'composer install' first.\n");
    exit(1);
}

use PhpCollective\Dto\Engine\EngineInterface;
use PhpCollective\Dto\Engine\NeonEngine;
use PhpCollective\Dto\Engine\PhpEngine;
use PhpCollective\Dto\Engine\XmlEngine;
use PhpCollective\Dto\Engine\YamlEngine;
use PhpCollective\Dto\Generator\ArrayConfig;
use PhpCollective\Dto\Generator\Builder;
use PhpCollective\Dto\Generator\ConsoleIo;
use PhpCollective\Dto\Generator\Generator;
use PhpCollective\Dto\Generator\IoInterface;
use PhpCollective\Dto\Generator\JsonSchemaGenerator;
use PhpCollective\Dto\Generator\TwigRenderer;
use PhpCollective\Dto\Generator\TypeScriptGenerator;

/**
 * Parse command line arguments.
 *
 * @param array<string> $argv
 *
 * @return array<string, mixed>
 */
function parseArgs(array $argv): array
{
    $options = [
        'command' => null,
        'config-path' => 'config/',
        'src-path' => 'src/',
        'output' => null, // Will be set based on command
        'namespace' => 'App',
        'format' => null,
        'dry-run' => false,
        'force' => false,
        'verbose' => false,
        'quiet' => false,
        'help' => false,
        'confirm' => false,
        'mapper' => false,
        // TypeScript options
        'single-file' => true,
        'readonly' => false,
        'strict-nulls' => false,
        'file-case' => 'pascal',
        // JSON Schema options
        'use-refs' => true,
        'date-format' => 'date-time',
    ];

    array_shift($argv); // Remove script name

    foreach ($argv as $arg) {
        if ($arg === '--help' || $arg === '-h') {
            $options['help'] = true;
        } elseif ($arg === '--verbose' || $arg === '-v') {
            $options['verbose'] = true;
        } elseif ($arg === '--quiet' || $arg === '-q') {
            $options['quiet'] = true;
        } elseif ($arg === '--dry-run') {
            $options['dry-run'] = true;
        } elseif ($arg === '--force') {
            $options['force'] = true;
        } elseif ($arg === '--confirm') {
            $options['confirm'] = true;
        } elseif ($arg === '--mapper') {
            $options['mapper'] = true;
        } elseif ($arg === '--single-file') {
            $options['single-file'] = true;
        } elseif ($arg === '--multi-file') {
            $options['single-file'] = false;
        } elseif ($arg === '--readonly') {
            $options['readonly'] = true;
        } elseif ($arg === '--strict-nulls') {
            $options['strict-nulls'] = true;
        } elseif (str_starts_with($arg, '--config-path=')) {
            $options['config-path'] = substr($arg, 14);
        } elseif (str_starts_with($arg, '--src-path=')) {
            $options['src-path'] = substr($arg, 11);
        } elseif (str_starts_with($arg, '--output=')) {
            $options['output'] = substr($arg, 9);
        } elseif (str_starts_with($arg, '--namespace=')) {
            $options['namespace'] = substr($arg, 12);
        } elseif (str_starts_with($arg, '--format=')) {
            $options['format'] = substr($arg, 9);
        } elseif (str_starts_with($arg, '--file-case=')) {
            $options['file-case'] = substr($arg, 12);
        } elseif ($arg === '--no-refs') {
            $options['use-refs'] = false;
        } elseif (str_starts_with($arg, '--date-format=')) {
            $options['date-format'] = substr($arg, 14);
        } elseif (!str_starts_with($arg, '-') && $options['command'] === null) {
            $options['command'] = $arg;
        }
    }

    return $options;
}

/**
 * Show help message.
 *
 * @return void
 */
function showHelp(): void
{
    echo <<<HELP
DTO Generator - Generate Data Transfer Objects from configuration files

Usage:
  vendor/bin/dto generate [options]
  vendor/bin/dto typescript [options]
  vendor/bin/dto jsonschema [options]
  vendor/bin/dto [options]

Commands:
  generate    Generate PHP DTOs from configuration (default)
  typescript  Generate TypeScript interfaces from configuration
  jsonschema  Generate JSON Schema from configuration

Common Options:
  --config-path=PATH   Path to config directory (default: config/)
  --format=FORMAT      Config format: xml, yaml, neon, php (default: auto-detect)
  --verbose, -v        Verbose output
  --quiet, -q          Minimal output
  --help, -h           Show this help

Generate Options:
  --src-path=PATH      Path to src directory (default: src/)
  --namespace=NS       Namespace for generated DTOs (default: App)
  --dry-run            Show what would be generated without writing files
  --force              Regenerate all DTOs, ignoring existing
  --confirm            Validate PHP syntax of generated files
  --mapper             Generate Doctrine-compatible mapper classes

TypeScript Options:
  --output=PATH        Path for TypeScript output (default: types/)
  --single-file        Generate all types in one file (default)
  --multi-file         Generate each type in separate file
  --readonly           Make all fields readonly
  --strict-nulls       Use '| null' instead of '?'
  --file-case=CASE     File naming: pascal, dashed, snake (default: pascal)

JSON Schema Options:
  --output=PATH        Path for JSON Schema output (default: schemas/)
  --single-file        Generate all schemas in one file with \$defs (default)
  --multi-file         Generate each schema in separate file
  --no-refs            Inline nested DTOs instead of using \$ref
  --date-format=FMT    Date format: date-time, date, string (default: date-time)

Examples:
  # Generate PHP DTOs with defaults (config/ -> src/Dto/)
  vendor/bin/dto generate

  # Specify custom paths and namespace
  vendor/bin/dto generate --config-path=dto/ --src-path=app/ --namespace=MyApp

  # Preview changes without writing
  vendor/bin/dto generate --dry-run --verbose

  # Generate with Doctrine-compatible mappers
  vendor/bin/dto generate --mapper

  # Generate TypeScript interfaces
  vendor/bin/dto typescript --output=frontend/src/types/

  # TypeScript with separate files
  vendor/bin/dto typescript --multi-file --file-case=dashed

  # TypeScript with readonly interfaces
  vendor/bin/dto typescript --readonly --strict-nulls

  # Generate JSON Schema
  vendor/bin/dto jsonschema --output=api/schemas/

  # JSON Schema with separate files
  vendor/bin/dto jsonschema --multi-file

  # JSON Schema with inline DTOs (no \$ref)
  vendor/bin/dto jsonschema --no-refs

Configuration Formats:
  The generator supports XML (default), YAML, NEON, and PHP formats.
  Place your DTO definitions in:
    - Single file: config/dto.xml (or .yaml, .neon, .php)
    - Multiple files: config/dto/*.xml (or .yaml, .neon, .php)


HELP;
}

/**
 * Detect config format from files in the config path.
 *
 * @param string $configPath
 *
 * @return string
 */
function detectFormat(string $configPath): string
{
    // Format => file extensions to check
    $formats = [
        'xml' => ['xml'],
        'yaml' => ['yaml', 'yml'],
        'neon' => ['neon'],
        'php' => ['php'],
    ];

    foreach ($formats as $format => $extensions) {
        foreach ($extensions as $ext) {
            // Check for single file
            if (file_exists($configPath . 'dto.' . $ext)) {
                return $format;
            }
            // Check for directory
            $dir = $configPath . 'dto/';
            if (is_dir($dir)) {
                $files = glob($dir . '*.' . $ext);
                if ($files !== [] && $files !== false) {
                    return $format;
                }
            }
        }
    }

    return 'xml'; // Default
}

/**
 * Create engine for the specified format.
 *
 * @param string $format
 *
 * @return \PhpCollective\Dto\Engine\EngineInterface
 */
function createEngine(string $format): EngineInterface
{
    return match ($format) {
        'yaml' => new YamlEngine(),
        'neon' => new NeonEngine(),
        'php' => new PhpEngine(),
        default => new XmlEngine(),
    };
}

// Parse arguments
$args = parseArgs($argv);

if ($args['help']) {
    showHelp();
    exit(0);
}

// Default command is generate
$command = $args['command'] ?? 'generate';

if (!in_array($command, ['generate', 'typescript', 'jsonschema'], true)) {
    fwrite(STDERR, "Unknown command: {$command}\n");
    fwrite(STDERR, "Run 'vendor/bin/dto --help' for usage.\n");
    exit(1);
}

// Normalize paths
$configPath = rtrim($args['config-path'], '/') . '/';

// Validate paths
if (!is_dir($configPath)) {
    fwrite(STDERR, "Config path does not exist: {$configPath}\n");
    exit(1);
}

// Detect or use specified format
$format = $args['format'] ?? detectFormat($configPath);

// Determine verbosity level
$verbosity = IoInterface::NORMAL;
if ($args['quiet']) {
    $verbosity = IoInterface::QUIET;
} elseif ($args['verbose']) {
    $verbosity = IoInterface::VERBOSE;
}

$io = new ConsoleIo($verbosity);

// Handle commands
if ($command === 'jsonschema') {
    // JSON Schema generation
    $outputPath = rtrim($args['output'] ?? 'schemas/', '/') . '/';

    $namespace = $args['namespace'];
    $config = new ArrayConfig([
        'namespace' => $namespace,
    ]);

    $engine = createEngine($format);
    $builder = new Builder($engine, $config);

    $io->out("Generating JSON Schema from {$configPath} to {$outputPath}", 1, IoInterface::VERBOSE);
    $io->out("Format: {$format}", 1, IoInterface::VERBOSE);
    $io->out('', 1, IoInterface::VERBOSE);

    try {
        $definitions = $builder->build($configPath, []);
    } catch (Exception $e) {
        $io->error($e->getMessage());
        exit(1);
    }

    $schemaGenerator = new JsonSchemaGenerator($io, [
        'singleFile' => $args['single-file'],
        'useRefs' => $args['use-refs'],
        'dateFormat' => $args['date-format'],
    ]);

    $count = $schemaGenerator->generate($definitions, $outputPath);
    $io->out("Generated {$count} JSON Schema file(s).");

    exit(0);
}

if ($command === 'typescript') {
    // TypeScript generation
    $outputPath = rtrim($args['output'] ?? 'types/', '/') . '/';

    $namespace = $args['namespace'];
    $config = new ArrayConfig([
        'namespace' => $namespace,
    ]);

    $engine = createEngine($format);
    $builder = new Builder($engine, $config);

    $io->out("Generating TypeScript from {$configPath} to {$outputPath}", 1, IoInterface::VERBOSE);
    $io->out("Format: {$format}", 1, IoInterface::VERBOSE);
    $io->out('', 1, IoInterface::VERBOSE);

    try {
        $definitions = $builder->build($configPath, []);
    } catch (Exception $e) {
        $io->error($e->getMessage());
        exit(1);
    }

    $tsGenerator = new TypeScriptGenerator($io, [
        'singleFile' => $args['single-file'],
        'fileNameCase' => $args['file-case'],
        'readonly' => $args['readonly'],
        'strictNulls' => $args['strict-nulls'],
    ]);

    $count = $tsGenerator->generate($definitions, $outputPath);
    $io->out("Generated {$count} TypeScript file(s).");

    exit(0);
}

// PHP DTO generation
$srcPath = rtrim($args['src-path'], '/') . '/';
$namespace = $args['namespace'];
$config = new ArrayConfig([
    'namespace' => $namespace,
]);

$engine = createEngine($format);
$builder = new Builder($engine, $config);
$renderer = new TwigRenderer(null, $config);

// Create generator and run
$generator = new Generator($builder, $renderer, $io, $config);

$io->out("Generating DTOs from {$configPath} to {$srcPath}Dto/", 1, IoInterface::VERBOSE);
$io->out("Namespace: {$namespace}\\Dto", 1, IoInterface::VERBOSE);
$io->out("Format: {$format}", 1, IoInterface::VERBOSE);
$io->out('', 1, IoInterface::VERBOSE);

$exitCode = $generator->generate($configPath, $srcPath, [
    'force' => $args['force'],
    'dryRun' => $args['dry-run'],
    'confirm' => $args['confirm'],
    'verbose' => $args['verbose'],
    'namespace' => $namespace,
    'mapper' => $args['mapper'],
]);

exit($exitCode);
